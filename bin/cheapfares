#!/usr/bin/env ruby
require 'gli'
require 'highline/import'
require 'ruby-progressbar'
require 'date'
require 'json'
require 'cheapfares'

include GLI::App

DATA_FILEPATH = './prices.json'

program_desc 'A utility for finding cheap rail fares'

version Cheapfares::VERSION

subcommand_option_handling :normal
arguments :strict

accept(Date) do |string|
  Date.parse(string)
end

desc 'Update fares'
long_desc 'Retrieve new fare information from the internet'
arg_name 'Origin, destination, earliest date, weeks to get'
command :update do |c|

  c.flag :d,    :default_value => Date.today,
                :arg_name => 'date',
                :type => Date,
                :desc => 'Travel date'
  c.flag :f,    :default_value => 'EUS',
                :arg_name => 'from',
                :type => String,
                :desc => 'Originating station'
  c.flag :t,    :default_value => 'EDB',
                :arg_name => 'to',
                :type => String,
                :desc => 'Destination station'
  c.flag :w,    :default_value => 12,
                :arg_name => 'weeks',
                :type => Integer,
                :desc => 'Weeks of data to get'

  c.action do |global_options,options,args|

    if options[:d] < Date.today
      raise "Can't get fares earlier than today. Exiting."
    end

    puts options[:dry]

    message = "Getting #{options[:w]} weeks of prices for #{options[:f]} to #{options[:t]} from #{options[:d]}. Proceed? (y/n)"
    exit unless HighLine.agree(message)

    prices = update_prices(origin:options[:f], destination:options[:t], start_date:options[:d], weeks:options[:w])
    save_prices_to_json(date:options[:d], origin:options[:f], destination:options[:t], prices:prices)
  end
end

desc 'Describe fare datafile'
long_desc 'Display date and journey details of datafile (if it exists)'
command :describe do |c|

  c.action do |global_options,options,args|
    data_hash = load_prices_from_JSON
    puts "\nMetadata:"
    generate_description(data_hash:data_hash)
  end

end

desc 'Report fares information'
command :report do |c|

  c.action do |global_options,options,args|
    data_hash = load_prices_from_JSON
    puts "\nFARE DATA:"
    generate_description(data_hash:data_hash)

    # generate dictionary of date objects and lowest price on that day
    prices = data_hash['prices']
    lowest_fare_hash = Hash.new
    prices.each do |day_string, price_hash|
      day = Date.parse(day_string)
      min_price = price_hash.values.compact.min
      lowest_fare_hash[day] = min_price
    end

    # remove nil values to protect maths
    lowest_fare_hash.delete_if { |day, price| price.nil? }

    worst_fare = lowest_fare_hash.max_by {|date, price| price} # [date, price]
    best_fare = lowest_fare_hash.min_by {|date, price| price}  # [date, price]
    bottom_quartile_fare = (worst_fare[1] - best_fare[1])/4.0 + best_fare[1]
    bottom_quartile_hash = lowest_fare_hash.select{|date,price| price <= bottom_quartile_fare}

    puts "Highest         : £#{'%.02f' % worst_fare[1]} (#{worst_fare[0]})"
    puts "Lowest          : £#{'%.02f' % best_fare[1]} (#{best_fare[0]})"
    puts "Bottom quartile : £#{'%.02f' % bottom_quartile_fare}"
    puts "-------------------------------------"
    bottom_quartile_hash.each do |day, price|
      puts "#{day}      : £#{'%.02f' % price}"
    end

    # pp lowest_fare_hash
  end
end

pre do |global,command,options,args|
  # Pre logic here
  # Return true to proceed; false to abort and not call the
  # chosen command
  # Use skips_pre before a command to skip this block
  # on that command only
  true
end

post do |global,command,options,args|
  # Post logic here
  # Use skips_post before a command to skip this
  # block on that command only
end

on_error do |exception|
  # Error logic here
  # return false to skip default error handling
  true
end

# Update prices from trainline
def update_prices(origin:, destination:, start_date:, weeks:)
  progressbar = ProgressBar.create(title:"Weeks:", format:"%t |%B| %c", starting_at:0, total:weeks)
  t = Cheapfares::Trainline.new
  prices = {}

  begin
    (0..weeks-1).each do |week|
      outward_date = start_date + week * 7

      t.fetchPricesLFromSite(
        outward_date:outward_date,
        origin: origin,
        destination: destination)
      prices = prices.merge(t.prices)
      progressbar.increment
    end

    return prices
  rescue
    raise "Couldn't update prices from web. Exiting."
  end
end

def save_prices_to_json(date:, origin:, destination:, prices:)
  data = Hash.new
  data[:date] = date
  data[:route] = {origin: origin, destination: destination}
  data[:prices] = prices
  begin
    File.open(DATA_FILEPATH, 'w') do |f|
      f.write(JSON.pretty_generate(data))
    end
    puts "Saved price data to #{DATA_FILEPATH}. Exiting."
  rescue
    raise "Couldn't save data to #{DATA_FILEPATH}. Exiting."
  end
end

def load_prices_from_JSON
  begin
    file = File.read(DATA_FILEPATH)
    return JSON.parse(file)
  rescue
    Puts "Can't load datafile #{DATA_FILEPATH}. Try 'update'. Exiting."
  end
end

def generate_description(data_hash:)
  date = Date.parse(data_hash['date'])
  weeks = data_hash['prices'].keys.count / 7
  puts "====================================="
  puts "Dates           : #{date}"
  puts "                : #{date + 7 * weeks}"
  puts "                : #{weeks} weeks"
  puts "Origin          : #{data_hash['route']['origin']}"
  puts "Destination     : #{data_hash['route']['destination']}"
  puts "-------------------------------------"
end

exit run(ARGV)
